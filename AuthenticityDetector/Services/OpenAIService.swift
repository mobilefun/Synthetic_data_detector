import Foundation
import UIKit

/// Service for communicating with OpenAI API to analyze text and images
class OpenAIService: ObservableObject {
    private let session = URLSession.shared

    // MARK: - Public Methods

    /// Analyzes text to determine if it's human-written or AI-generated
    /// - Parameter text: The text to analyze
    /// - Returns: A DetectionResult containing authenticity, confidence, and reasoning
    /// - Throws: APIError if the request fails or response is invalid
    func analyzeText(_ text: String) async throws -> DetectionResult {
        let prompt = """
        Analyze the following text to determine if it was written by a human or generated by AI. Respond ONLY with a valid JSON object in this exact format:

        {
          "isAuthentic": boolean,
          "confidence": number,
          "reasoning": "string"
        }

        Where:
        - isAuthentic: true for human-written, false for AI-generated
        - confidence: number between 0 and 1
        - reasoning: brief explanation of your analysis

        Text to analyze: "\(text)"
        """
        
        let request = OpenAIRequest(
            model: "gpt-4o",
            messages: [
                Message(
                    role: "system",
                    content: [
                        MessageContent(
                            type: "text",
                            text: "You are an AI content detector. You must respond with ONLY valid JSON. No explanations, no markdown formatting, no code blocks - just pure JSON.",
                            imageUrl: nil
                        )
                    ]
                ),
                Message(
                    role: "user",
                    content: [
                        MessageContent(
                            type: "text",
                            text: prompt,
                            imageUrl: nil
                        )
                    ]
                )
            ],
            maxTokens: 300,
            temperature: 0.1
        )
        
        let response = try await makeAPICall(request: request)
        return try parseDetectionResult(from: response, contentType: .text)
    }

    // MARK: - Image Analysis

    /// Analyzes an image to determine if it's a real photo or AI-generated
    /// - Parameter imageData: The image data to analyze (JPEG format)
    /// - Returns: A DetectionResult containing authenticity, confidence, and reasoning
    /// - Throws: APIError if the request fails or response is invalid
    func analyzeImage(_ imageData: Data) async throws -> DetectionResult {
        let base64Image = imageData.base64EncodedString()
        let dataUrl = "data:image/jpeg;base64,\(base64Image)"
        
        let prompt = """
        Analyze this image to determine if it's a real photograph or AI-generated. Respond ONLY with a valid JSON object in this exact format:

        {
          "isAuthentic": boolean,
          "confidence": number,
          "reasoning": "string"
        }

        Where:
        - isAuthentic: true for real photo, false for AI-generated
        - confidence: number between 0 and 1
        - reasoning: brief explanation of your analysis
        """
        
        let request = OpenAIRequest(
            model: "gpt-4o",
            messages: [
                Message(
                    role: "system",
                    content: [
                        MessageContent(
                            type: "text",
                            text: "You are an AI image detector. You must respond with ONLY valid JSON. No explanations, no markdown formatting, no code blocks - just pure JSON.",
                            imageUrl: nil
                        )
                    ]
                ),
                Message(
                    role: "user",
                    content: [
                        MessageContent(
                            type: "text",
                            text: prompt,
                            imageUrl: nil
                        ),
                        MessageContent(
                            type: "image_url",
                            text: nil,
                            imageUrl: ImageUrl(url: dataUrl, detail: "high")
                        )
                    ]
                )
            ],
            maxTokens: 300,
            temperature: 0.1
        )
        
        let response = try await makeAPICall(request: request)
        return try parseDetectionResult(from: response, contentType: .image)
    }

    // MARK: - Private Methods
    
    private func makeAPICall(request: OpenAIRequest) async throws -> OpenAIResponse {
        guard let url = URL(string: APIConfiguration.baseURL + APIConfiguration.chatCompletionsEndpoint) else {
            throw APIError.invalidURL
        }
        
        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = "POST"
        urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
        urlRequest.setValue("Bearer \(APIConfiguration.apiKey)", forHTTPHeaderField: "Authorization")
        
        do {
            urlRequest.httpBody = try JSONEncoder().encode(request)
        } catch {
            throw APIError.encodingError(error)
        }
        
        do {
            let (data, response) = try await session.data(for: urlRequest)
            
            guard let httpResponse = response as? HTTPURLResponse else {
                throw APIError.invalidResponse
            }
            
            guard 200...299 ~= httpResponse.statusCode else {
                throw APIError.httpError(httpResponse.statusCode)
            }
            
            return try JSONDecoder().decode(OpenAIResponse.self, from: data)
        } catch let error as DecodingError {
            throw APIError.decodingError(error)
        } catch {
            throw APIError.networkError(error)
        }
    }
    
    private func parseDetectionResult(from response: OpenAIResponse, contentType: DetectionResult.ContentType) throws -> DetectionResult {
        guard let content = response.choices.first?.message.content else {
            throw APIError.noContent
        }
        
        // Clean the content - remove any markdown formatting or extra text
        let cleanedContent = content
            .replacingOccurrences(of: "```json", with: "")
            .replacingOccurrences(of: "```", with: "")
            .trimmingCharacters(in: .whitespacesAndNewlines)
        
        guard let data = cleanedContent.data(using: .utf8) else {
            throw APIError.invalidContent
        }
        
        do {
            // First try direct JSON decoding
            let decoder = JSONDecoder()
            let jsonResult = try decoder.decode(JSONResult.self, from: data)
            
            return DetectionResult(
                isAuthentic: jsonResult.isAuthentic,
                confidence: jsonResult.confidence,
                reasoning: jsonResult.reasoning,
                contentType: contentType
            )
        } catch {
            // Fallback to manual parsing
            do {
                let jsonObject = try JSONSerialization.jsonObject(with: data) as? [String: Any]
                guard let isAuthentic = jsonObject?["isAuthentic"] as? Bool,
                      let confidence = jsonObject?["confidence"] as? Double,
                      let reasoning = jsonObject?["reasoning"] as? String else {
                    throw APIError.invalidJSONStructure
                }
                
                return DetectionResult(
                    isAuthentic: isAuthentic,
                    confidence: confidence,
                    reasoning: reasoning,
                    contentType: contentType
                )
            } catch {
                print("Raw API Response: \(content)")
                print("Cleaned content: \(cleanedContent)")
                throw APIError.jsonParsingError(error)
            }
        }
    }
}

// Helper struct for direct JSON decoding
private struct JSONResult: Codable {
    let isAuthentic: Bool
    let confidence: Double
    let reasoning: String
}

enum APIError: LocalizedError {
    case invalidURL
    case encodingError(Error)
    case networkError(Error)
    case invalidResponse
    case httpError(Int)
    case decodingError(Error)
    case noContent
    case invalidContent
    case invalidJSONStructure
    case jsonParsingError(Error)
    
    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "Invalid API URL"
        case .encodingError(let error):
            return "Request encoding failed: \(error.localizedDescription)"
        case .networkError(let error):
            return "Network error: \(error.localizedDescription)"
        case .invalidResponse:
            return "Invalid response from server"
        case .httpError(let code):
            return "HTTP error: \(code)"
        case .decodingError(let error):
            return "Response decoding failed: \(error.localizedDescription)"
        case .noContent:
            return "No content in response"
        case .invalidContent:
            return "Invalid content format"
        case .invalidJSONStructure:
            return "Invalid JSON structure in response"
        case .jsonParsingError(let error):
            return "JSON parsing failed: \(error.localizedDescription)"
        }
    }
}